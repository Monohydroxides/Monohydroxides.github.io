---
tag: 2022_多校训练
---

<head>
    <figure>
    <a><img src="{{site.url}}/_img/2022-08-03-2022_杭电多校训练_round5_1002.png"></a>
    </figure>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# 2022_杭电多校训练 round5 1002

## 1002

**题目描述**: [题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=7186)

**思路**: 推公式题, 之前没有见过  [PN筛法](https://www.cnblogs.com/whx1003/p/14123436.html), 通过这道题了解一下该算法并加深对迪利克雷卷积的理解.

公式推导过程如下.

![2022-08-03-2022_杭电多校训练_round5_1002](/_img/2022-08-03-2022_杭电多校训练_round5_1002.png)

**代码实现**: (注意 $work$ 函数的搜索方式)

```cpp
#pragma optimize(2)
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const ll N = 1e12 + 10, M = 1e7 + 10, mod = 4179340454199820289;

ll m;
ll primes[M], cnt;
ll inv[65];
bool st[M];

ll mul(ll a, ll b) {
    return (a * b - (unsigned long long)((long double) a / mod * b) * mod + mod) % mod;
}

ll qmi(ll a, ll b) {
    ll res = 1;
    while(b) {
        if(b & 1)   res = mul(res, a);
        a = mul(a, a);
        b >>= 1;
    }
    return res;
}

void init() {
    for(int k = 1; k <= 64; ++k) {
        inv[k] = qmi(k, mod - 2);
    }
    ll mx = sqrt(N);
    for(ll i = 2; i <= mx + 5; ++i) {
        if(!st[i])  primes[cnt++] = i;
        for(ll j = 0; i * primes[j] <= mx + 5; ++j) {
            st[primes[j] * i] = 1;
            if(i % primes[j] == 0)  break;
        }
    }
}

ll calch(ll p, ll k, ll pk) {
    return mod - mul(pk, mul(inv[k], inv[k - 1]));
}

ll work(ll n, ll idx, ll hd) {
    ll res = mul(mul(n, mul(n + 1, inv[2])), hd);
    for(ll i = idx; i < cnt; ++i) {
        ll prime = primes[i], k = 1;
        ll cur = n / prime, pk = prime;
        if(cur < prime) break;
        while(cur >= prime) {
            cur /= prime;
            pk *= prime;
            ++k;
            res = (res + work(cur, i + 1, mul(hd, calch(prime, k, pk)))) % mod;
            res = (res + mod) % mod;
        }
    }
    return res;
}

int main() {
    cin.tie(0), cout.tie(0);
    ios::sync_with_stdio(false);
    int T;
    scanf("%d", &T);
    init();
    while(T--) {
        scanf("%lld", &m);
        printf("%lld\n", mul(work(m, 0, 1), qmi(m, mod - 2)));
    }
    return 0;
}
```