---
tag: 数学
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# 习题

### ****[Crash的数字表格](https://www.luogu.com.cn/problem/P1829)****

**题目描述**: 对 $n, m(1\leq n, m \leq 10^7)$, 求 $\sum_{i = 1}^{n} \sum_{j = 1}^m lcm(i,j)$.

**思路**:

先将求最小公倍数变为求最大公约数, 再改写枚举最大公因数的形式:

$$
\begin{aligned}
\sum_{i = 1}^{n} \sum_{j = 1}^m lcm(i,j) &= 
\sum_{i = 1}^{n} \sum_{j = 1}^m \frac{ij}{gcd(i,j)} \\ &= 
\sum_{i = 1}^{n} \sum_{j = 1}^m \sum_{d \mid i,d \mid j, gcd(\frac{i}{d}, \frac{j}{d})=1}\frac{ij}{d}
\end{aligned}
$$

改变求和次序:

$$
=\sum_{d=1}^nd \sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{m}{d}}[gcd(i,j)=1]\cdot ij
$$

不难发现, $\sum_{d=1}^nd$ 很好求, 现在需要对后面的式子进行一定的化简.

令

$$
sum(n,m) = \sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=1]\cdot ij
$$

枚举约数:

$$
sum(n,m) =\sum_{d=1}^n \sum_{d \mid i}^n\sum_{d\mid j}^m \mu(d) \cdot ij
$$

令 $i = d i^{\prime}, j=dj^{\prime}$, 有:

$$
\begin{aligned}
sum(n,m) &=\sum_{d=1}^n \mu(d)\cdot d^2 \sum_{i^{\prime}=1}^{\frac{n}{d}}\sum_{j^{\prime}=1}^{\frac{m}{d}}i^{\prime}j^{\prime} \\
&=\sum_{d=1}^n \mu(d)\cdot d^2 \cdot \frac{(1 + \frac{n}{d})(\frac{n}{d})}{2}\cdot \frac{(1 + \frac{m}{d})(\frac{m}{d})}{2}
\end{aligned}
$$

对于 $\sum_{d=1}^{n}\mu(d) \cdot d^2$, 可以对其进行 $O(n)$ 的预处理前缀和, 后面的部分可以 $O(1)$计算.

将 $sum(n,m)$ 代回原式, 得到:

$$
ans = \sum_{d=1}^nd \cdot sum(\lfloor \frac{n}{d} \rfloor, \lfloor \frac{m}{d} \rfloor)
$$

**代码实现**:

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

const int N = 1e7 + 1;

int n, m;
int mod = 20101009;
int primes[N], cnt, st[N], mu[N], smu[N], sum[N];

void init(){ // 线性求莫比乌斯函数
    mu[1] = 1;
    int k = min(m, n);
    for(int i = 2; i <= k; ++i){
        if(!st[i])  primes[cnt++] = i, mu[i] = -1;
        for(int j = 0; primes[j] * i < N; ++j){
            st[primes[j] * i] = 1;
            if(i % primes[j] == 0)  {
                mu[i * primes[j]] = 0; 
                break;
            }
            mu[primes[j] * i] = -mu[i];
        }
    }
    for(int i = 1; i <= k; ++i){
        smu[i] = smu[i - 1] + mu[i];
    }
    for(int i = 1; i <= k; ++i){ // O(k) 预处理 mu[d] * d^2
        sum[i] = (sum[i - 1] + (LL) i * i % mod * (mu[i] + mod) % mod) % mod;
    }
}

int g(int x, int i){ // 整除分块函数
    return x / (x / i);
}

LL calc(int a, int b){ // O(1) 求 sum 的后半部分
    return (LL)(1 + a) * a / 2 % mod * ((LL)(1 + b) * b / 2 % mod) % mod;
}

int func(int a, int b){ // 即公式中的 sum(n, m) 函数
    int res = 0, r;
    for(int l = 1; l <= min(a, b); l = r + 1){
        r = min(g(a, l), g(b, l));
        res = (res + (LL)(sum[r] - sum[l - 1]) * calc(a / l, b / l) % mod) % mod;
    }
    return res;
}

int work(){
    int res = 0;
    for(int l = 1, r; l <= min(n, m); l = r + 1){
        r = min(g(n, l), g(m, l));
        res = (res + (LL)(r - l + 1) * (l + r) / 2 % mod * func(n / l, m / l) % mod) % mod;
    }
    return (res + mod) % mod; 
}

int main(){
    cin >> n >> m;
    init();
    cout << work() << endl;
    return 0;
}
```