<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

## 5.1 传输层概述
传输层是只有主机才具有的，其主要功能为进程和进程之间的逻辑通信、复用（应用层的所有应用进程都可以通过传输层传输到网络层）和分用（传输层从网络层收到数据后交付指明的应用进程）、对收到的报文进行差错检测。

传输层主要有两种协议：TCP（面向连接的传输控制协议）、UDP（无连接的用户数据报协议）。

TCP 可靠，面向连接，但因为要保证可靠性因此时延较大；
UPD 不可靠，无连接，不需要保证可靠性因此时延较小。

端口是传输层的 SAP，标识主机中的应用进程。这里的端口是逻辑上的端口，只有本地意义，其长度为 16bit，端口分为服务端使用的端口号和客户端使用的端口号，服务端端口号分为熟知端口号 0-1023 和登记端口号 1024-49151，客户端使用的端口号为 49152-65535。

一些经典的熟知端口号：FTP 21，TELNET 23，SMTP 25，DNS 53，TFTP 69，HTTP 80，SNMP 161。

在网络中采用发送方和接收方的套接字组合来识别端点，套接字（Socket）唯一标识了网络中的一个主机和在它之上的一个进程，套接字 = （主机 IP 地址，端口号）。

## 5.2 UDP 协议
UDP 只是在 IP 数据服务之上增加了很少的功能，即复用和差错检测。

UDP 的主要特点：
1. UDP 为无连接的，减少了开销和发送数据之前的时延
2. UDP 不保证可靠交付
3. UDP 是面向报文的（保留应用层报文的结构，一次发送一个完整的报文），适合一次性传输少量数据的网络应用。
4. UDP 无拥塞控制，适合很多实时应用

**UDP 的格式**

UDP 分为首部字段和数据字段。

UDP 首部字段非常简单，包括 16 位源端口号，16 位目的端口号，16 位 UDP 长度（首部 + 数据字段的全部长度，单位为 1B），16 位 UDP 检验和（检测整个 UDP 数据报是否有错误，有错误就丢弃），一共 8B。

**UDP 的校验**
在 UDP 用户数据报计算校验和时，会使用伪首部。
伪首部的结构为 4B 源 IP 地址，4B 目的 IP 地址，1B 全 0，1B UDP标识为 17，2B UDP 长度（UDP 长度不包括伪首部）。

UDP 的校验方法与 IP 的首部检验和类似，在发送端时：

1. 填上伪首部
2. 全 0 填充检验和字段
3. 用 0 填充数据部分补齐 4B
4. 把伪首部 + 首部 + 数据部分采用二进制反码求和
5. 把结果求反码填入检验和字段
6. 去掉伪首部发送数据

在接收端时：
1. 填上伪首部
2. 伪首部 + 首部 + 数据部分采用二进制反码求和（此时的校验和字段不一定是全 0 的）
3. 如果结果全为 1 则没有差错，否则发生差错。

## 5.3 TCP 协议
### 5.3.1 TCP 协议特点

TCP 协议是面向连接（点对点连接，每条 TCP 连接只能有两个端点，两个端点之间可以全双工通信）的传输层协议。

TCP 非常可靠，可以做到无差错，不丢失，不重复，不乱序。

TCP 把应用程序交下来的数据视为一连串无结构的字节流。

### 5.3.2 TCP 格式
TCP 报文段也主要分为首部和数据部分，其中首部分为 20B 的固定首部和选项，在添加选项之后，TCP 要求补齐至 4B 的整数倍。

TCP 协议的首部按顺序为如下内容：

2B 源端口，2B 目的端口。

4B 序号，序号为一个 TCP 报文中传送的字节流中的第一个字节的顺序编号。

4B 确认号，期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，说明序号 N-1 及之前的所有数据都已经被正确接收。

4bit 数据偏移，标识 TCP 报文段的数据起始处距离 TCP 报文段的起始处的距离，单位为 4B，其实质上标识了首部的长度。

6bit 保留位。

6bit 控制位，分别为

紧急位 URG，当 URG = 1 时，表示此报文段中有紧急数据，是高优先级的数据，应该尽快传送，不应在缓存里排队。

确认位 ACK，当 ACK = 1 时，确认位有效，在连接建立后所有传送的报文段都需要把 ACK 置为 1。

推送位 PSH，当 PSH = 1 时，接收方尽快交付接收应用进程，不再等到缓存填满时再向上交付。

复位 RST，当 RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，再重新建立连接。

同步位 SYN，当 SYN = 1 时，标明这是一个连接请求/连接接受报文。

终止位 FIN，当 FIN = 1 时，标明此报文段发送方数据已经发完，要求释放连接。

2B 窗口，为发送本报文段的一方（即自己）的接收窗口，即现在允许对方发送的数据量。

2B 检验和，检验首部和数据，检验时要加上 12B 的伪首部，其中的第四个字段为 6，表示 TCP 协议。

2B 紧急指针，当 URG = 1 时起作用，指出本报文段中紧急数据的字节数。

接下来为长度可变的选项，如最大报文段长度 MSS，窗口扩大字段，时间戳字段等。

需要注意的是，TCP 协议的首部需要填充全 0 至 4B 的整数倍。

### 5.3.3 TCP 连接管理
TCP 连接传输的三个阶段：连接建立-连接传送-连接释放。

TCP 连接的建立采用 C/S 方式，主动发起连接的应用进程叫客户，被动等待连接建立的应用进程叫服务器。

三次握手：
1. 客户端发送连接请求报文段（SYN = 1，序号 = x（随机）），无应用层数据。
2. 服务器为该 TCP 连接分配缓存和变量，并向客户端返回确认报文段（SYN = 1，ACK = 1，序号 = y（随机），确认号 = x + 1），允许连接，无应用层数据。
3. 客户端为 TCP 连接分配缓存和变量，并向服务端返回确认的确认（SYN = 0，ACK = 1，序号 = x + 1，确认号 = y + 1），该过程可以携带数据。

SYN 洪泛攻击

该攻击利用了 TCP 协议的三次握手，攻击者发送第一次握手的数据包，服务器返回 ACK 后，**攻击者不进行第三次握手**，使该 TCP 连接处于半连接状态，此时服务器收不到再确认，会重复发送 ACK 给攻击者。攻击者发起大量 TCP 连接，消耗服务器资源，最终导致服务器死机。该攻击可以通过设置 SYN cookie 解决。

TCP 连接释放

参与一条 TCP 连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的资源将被释放。

四次握手：
1. 客户端发送连接释放报文段（FIN = 1，序号 = u），停止发送数据，主动关闭 TCP 连接。
2. 服务器回送一个确认报文段（ACK = 1，序号 = v，确认号 = u + 1），客户到服务器这个方向的连接就释放了，这视为半关闭状态。
3. 服务器端发送完数据，发出连接释放报文段（FIN = 1，ACK = 1，序号 = w，确认号 = v + 1），主动关闭 TCP 连接。
4. 客户端回送一个确认报文段，等到时间等待计时器设置的 2MSL（最长报文段寿命）后，连接彻底关闭。

### 5.3.4 TCP 可靠传输
TCP 实现可靠传输的机制主要有校验、序号、确认、重传。

校验机制与 UDP 校验机制相同，通过增加伪首部，计算校验和完成。

基于 TCP 协议中的序号，产生了 TCP 中的确认（累计确认）与重新发送机制（TCP 的发送方在重传时间内没有收到确认就要重传已经发送的报文段，也叫超时重传）。TCP 采用自适应算法，动态地对重传时间做出了调整（加权平均往返时间）。

### 5.3.5 TCP 流量控制
TCP 使用滑动窗口机制实现流量控制，在通信过程中，接收方根据自己接收缓存的大小，动态调整发送方的发送窗口大小，即接收窗口 rwnd（接收方在确认报文段的窗口字段中将 rwnd 通知发送给对方），发送方的发送窗口取接收窗口 rwnd 和拥塞窗口 cwnd 的最小值。

TCP 为每个连接设置有一个持续计时器，当 TCP 连接的一方收到对方的零窗口通知（即把窗口大小设置为 0），就启动持续计时器。

如果持续计时器设置的时间到期，就发送一个零窗口探测报文段，接收方收到探测报文段时给出现在的窗口值，如果窗口值仍然是 0，那么发送方就重新设置持续计时器。

### 5.3.6 TCP 拥塞控制
拥塞发生的状况：对资源需求的总和大于可用资源。

越多人用 -> 网络性能越差，类比鱼死水臭，水更臭鱼更死，因此我们需要使用拥塞控制防止过多的数据进入网络中。

拥塞控制更像是多方对资源的占用，流量控制为发送速率与接收速率的不匹配。

拥塞控制主要有慢开始、拥塞避免、快重传、快恢复四种方法，这四种方法比较简单。

拥塞控制的方法需要以下假设：
1. 数据是单方向发送的，另一个方向只进行传送确认；
2. 接收方总是有足够大的缓存空间，发送窗口的大小在这里取决于拥塞程度。

  
